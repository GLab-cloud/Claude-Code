<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Interactive Cosmos</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: #000;
      }
      #canvas {
        display: block;
      }
      #info {
        position: absolute;
        top: 20px;
        left: 20px;
        color: white;
        background: rgba(0, 0, 0, 0.7);
        padding: 15px;
        border-radius: 8px;
        font-size: 14px;
        max-width: 300px;
        backdrop-filter: blur(10px);
      }
      #controls {
        position: absolute;
        bottom: 20px;
        left: 20px;
        color: white;
        background: rgba(0, 0, 0, 0.7);
        padding: 15px;
        border-radius: 8px;
        backdrop-filter: blur(10px);
      }
      button {
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.3);
        color: white;
        padding: 8px 15px;
        margin: 5px;
        border-radius: 5px;
        cursor: pointer;
        transition: all 0.3s;
      }
      button:hover {
        background: rgba(255, 255, 255, 0.2);
        border-color: rgba(255, 255, 255, 0.5);
      }
      #loading {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: white;
        font-size: 24px;
        text-align: center;
      }
      .slider-container {
        margin: 10px 0;
      }
      input[type="range"] {
        width: 200px;
      }
    </style>
  </head>
  <body>
    <div id="loading">Loading Star Catalog...</div>
    <div id="info" style="display: none">
      <h3 style="margin-top: 0">ðŸŒŒ Interactive Cosmos</h3>
      <div id="stats">
        Stars: <span id="starCount">0</span><br />
        Data: Yale Bright Star Catalog<br />
      </div>
      <p style="font-size: 12px; margin-bottom: 0">
        <strong>Controls:</strong><br />
        â€¢ Drag to rotate<br />
        â€¢ Scroll to zoom<br />
        â€¢ Click stars for info
      </p>
    </div>
    <div id="controls" style="display: none">
      <div class="slider-container">
        <label>Star Size: <span id="sizeValue">1.0</span></label
        ><br />
        <input
          type="range"
          id="sizeSlider"
          min="0.5"
          max="3"
          step="0.1"
          value="1.0"
        />
      </div>
      <div class="slider-container">
        <label>Speed: <span id="speedValue">1.0</span></label
        ><br />
        <input
          type="range"
          id="speedSlider"
          min="0"
          max="3"
          step="0.1"
          value="1.0"
        />
      </div>
      <button id="toggleRotation">Pause Rotation</button>
      <button id="resetView">Reset View</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
      let scene, camera, stars, reraycaster, mouse, renderer;
      let starData = [];
      let rotating = true;
      let rotationSpeed = 0.0005;
      let starSize = 1.0;
      // Convert RA/DEC to Cartesian coordinates
      function raDecToCartesian(ra, dec, distance = 100) {
        const raHours =
          parseFloat(ra.split(":")[0]) +
          parseFloat(ra.split(":")[1]) / 60 +
          parseFloat(ra.split(":")[2]) / 3600;
        const raRad = (raHours / 24) * 2 * Math.PI;

        const decParts = dec.split(":");
        const decSign = decParts[0].includes("-") ? -1 : 1;
        const decDeg =
          Math.abs(parseFloat(decParts[0])) +
          parseFloat(decParts[1]) / 60 +
          parseFloat(decParts[2]) / 3600;
        const decRad = (decSign * decDeg * Math.PI) / 180;

        const x = distance * Math.cos(decRad) * Math.cos(raRad);
        const y = distance * Math.sin(decRad);
        const z = distance * Math.cos(decRad) * Math.sin(raRad);

        return { x, y, z };
      }

      // Get star color based on spectral type
      function getStarColor(spectralType) {
        if (!spectralType) return 0xffffff;
        const type = spectralType.charAt(0).toUpperCase();
        const colorMap = {
          O: 0x9bb0ff, // Blue
          B: 0xaabfff, // Blue-white
          A: 0xcad7ff, // White
          F: 0xf8f7ff, // Yellow-white
          G: 0xfff4ea, // Yellow (Sun-like)
          K: 0xffd2a1, // Orange
          M: 0xffcc6f, // Red
        };
        return colorMap[type] || 0xffffff;
      }

      async function init() {
        // Setup scene
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.position.z = 150;

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();

        // Load star data
        try {
          const response = await fetch(
            "https://raw.githubusercontent.com/aduboisforge/Bright-Star-Catalog-JSON/master/BSC.json"
          );
          const data = await response.json();

          document.getElementById("loading").style.display = "none";
          document.getElementById("info").style.display = "block";
          document.getElementById("controls").style.display = "block";

          createStars(data);
          document.getElementById("starCount").textContent = data.length;
        } catch (error) {
          document.getElementById("loading").textContent =
            "Error loading catalog. Using sample data...";
          createSampleStars();
        }

        // Add ambient starfield background
        createBackground();

        // Event listeners
        window.addEventListener("resize", onWindowResize);
        renderer.domElement.addEventListener("mousemove", onMouseMove);
        renderer.domElement.addEventListener("click", onMouseClick);

        document.getElementById("sizeSlider").addEventListener("input", (e) => {
          starSize = parseFloat(e.target.value);
          document.getElementById("sizeValue").textContent =
            starSize.toFixed(1);
          updateStarSizes();
        });

        document
          .getElementById("speedSlider")
          .addEventListener("input", (e) => {
            rotationSpeed = parseFloat(e.target.value) * 0.0005;
            document.getElementById("speedValue").textContent = e.target.value;
          });

        document
          .getElementById("toggleRotation")
          .addEventListener("click", () => {
            rotating = !rotating;
            document.getElementById("toggleRotation").textContent = rotating
              ? "Pause Rotation"
              : "Resume Rotation";
          });

        document.getElementById("resetView").addEventListener("click", () => {
          camera.position.set(0, 0, 150);
          camera.lookAt(0, 0, 0);
        });

        animate();
      }

      function createStars(data) {
        const geometry = new THREE.BufferGeometry();
        const positions = [];
        const colors = [];
        const sizes = [];

        starData = data.slice(0, 3000); // Use first 3000 stars for performance

        starData.forEach((star) => {
          const pos = raDecToCartesian(star.RA, star.DEC);
          positions.push(pos.x, pos.y, pos.z);

          const color = new THREE.Color(getStarColor(star["Title HD"]));
          colors.push(color.r, color.g, color.b);

          // Size based on magnitude (brighter = larger)
          const magnitude = parseFloat(star.MAG) || 6;
          const size = Math.max(1, (7 - magnitude) * 2);
          sizes.push(size);
        });

        geometry.setAttribute(
          "position",
          new THREE.Float32BufferAttribute(positions, 3)
        );
        geometry.setAttribute(
          "color",
          new THREE.Float32BufferAttribute(colors, 3)
        );
        geometry.setAttribute(
          "size",
          new THREE.Float32BufferAttribute(sizes, 1)
        );

        const material = new THREE.PointsMaterial({
          size: 2,
          vertexColors: true,
          sizeAttenuation: true,
          transparent: true,
          opacity: 0.9,
        });

        stars = new THREE.Points(geometry, material);
        scene.add(stars);
      }

      function createBackground() {
        const bgGeometry = new THREE.BufferGeometry();
        const bgPositions = [];
        const bgColors = [];

        for (let i = 0; i < 5000; i++) {
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos(Math.random() * 2 - 1);
          const radius = 200;

          bgPositions.push(
            radius * Math.sin(phi) * Math.cos(theta),
            radius * Math.sin(phi) * Math.sin(theta),
            radius * Math.cos(phi)
          );

          const c = Math.random() * 0.5 + 0.5;
          bgColors.push(c, c, c);
        }

        bgGeometry.setAttribute(
          "position",
          new THREE.Float32BufferAttribute(bgPositions, 3)
        );
        bgGeometry.setAttribute(
          "color",
          new THREE.Float32BufferAttribute(bgColors, 3)
        );

        const bgMaterial = new THREE.PointsMaterial({
          size: 0.5,
          vertexColors: true,
          transparent: true,
          opacity: 0.6,
        });

        const background = new THREE.Points(bgGeometry, bgMaterial);
        scene.add(background);
      }

      function createSampleStars() {
        const geometry = new THREE.BufferGeometry();
        const positions = [];
        const colors = [];

        for (let i = 0; i < 1000; i++) {
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos(Math.random() * 2 - 1);
          const radius = 100;

          positions.push(
            radius * Math.sin(phi) * Math.cos(theta),
            radius * Math.sin(phi) * Math.sin(theta),
            radius * Math.cos(phi)
          );

          const color = new THREE.Color().setHSL(Math.random(), 0.5, 0.7);
          colors.push(color.r, color.g, color.b);
        }

        geometry.setAttribute(
          "position",
          new THREE.Float32BufferAttribute(positions, 3)
        );
        geometry.setAttribute(
          "color",
          new THREE.Float32BufferAttribute(colors, 3)
        );

        const material = new THREE.PointsMaterial({
          size: 2,
          vertexColors: true,
        });

        stars = new THREE.Points(geometry, material);
        scene.add(stars);

        document.getElementById("starCount").textContent = "1000 (sample)";
      }

      function updateStarSizes() {
        if (stars && stars.material) {
          stars.material.size = 2 * starSize;
        }
      }

      function onMouseMove(event) {
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      }

      function onMouseClick() {
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObject(stars);

        if (intersects.length > 0) {
          const idx = intersects[0].index;
          if (starData[idx]) {
            const star = starData[idx];
            alert(
              `Star #${star["harvard_ref_#"]}\nMagnitude: ${star.MAG}\nSpectral Type: ${star["Title HD"]}\nRA: ${star.RA}\nDEC: ${star.DEC}`
            );
          }
        }
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      let isDragging = false;
      let previousMousePosition = { x: 0, y: 0 };
      renderer = new THREE.WebGLRenderer({ antialias: true });

      renderer.domElement.addEventListener("mousedown", (e) => {
        isDragging = true;
        previousMousePosition = { x: e.clientX, y: e.clientY };
      });

      renderer.domElement.addEventListener("mousemove", (e) => {
        if (isDragging && stars) {
          const deltaX = e.clientX - previousMousePosition.x;
          const deltaY = e.clientY - previousMousePosition.y;

          stars.rotation.y += deltaX * 0.005;
          stars.rotation.x += deltaY * 0.005;

          previousMousePosition = { x: e.clientX, y: e.clientY };
        }
      });

      renderer.domElement.addEventListener("mouseup", () => {
        isDragging = false;
      });

      renderer.domElement.addEventListener("wheel", (e) => {
        e.preventDefault();
        camera.position.z += e.deltaY * 0.1;
        camera.position.z = Math.max(50, Math.min(300, camera.position.z));
      });

      function animate() {
        requestAnimationFrame(animate);

        if (stars && rotating && !isDragging) {
          stars.rotation.y += rotationSpeed;
        }

        renderer.render(scene, camera);
      }

      init();
    </script>
  </body>
</html>
